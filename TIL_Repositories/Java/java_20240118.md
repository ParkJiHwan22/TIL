# 객체지향 프로그래밍


### 객체지향 프로그래밍(OOP, Object Oriented Programming)
- 객체: 사물과 같이 유형적인 것과 개념이나 논리와 같은 무형적인 것들
    - 객체 단위로 나누어서(조직화), 객체 간의 상호작용으로 SW를 설계, 구현
    - 데이터와 이 데이터에 관련된 알고리즘(로직)이 하나의 단위로 묶여있는 것
    - 캐릭터(속성): 이름, 레벨, 이미지, 직업, 소속, 스킬
    = 알고리즘 로직: 행위와 기능을 의미한다, 예를 들면 공격한다, 아이템을 줍는다
- 지향: 작정하거나 지정한 방향으로 나아감
- 객체 모델링: 현실세계의 객체를 SW 객체로 설계하는 것

### 클래스(Class)
- 객체를 만드는 설계도
- 유저들이 캐릭터를 생성할 때, 만들어져있는 클래스로 캐릭터를 찍어낼 수 있음
- 붕어빵 틀이라고 생각하면 쉬움
- 클래스를 만들고 클래스를 기반으로 객체를 생성

### 인스턴스(Instance)
- 클래스를 통해 생성된 객체
- 메모리에 실제 데이터와 함수들이 올라간 것, 객체가 생성된다.

### **`객체지향 프로그래밍 특징 (A PIE)`**
- Abstraction (추상화): 현실에 있는 객체를 가지고 소프트웨어 객체를 만들어냄, 불필요한 속성을 배제하고 필요한 속성만 가지고 객체를 만드는 것, 쓰이는 속성만 추출하며 만드는 것을 의미함

- Polymorphism (다형성): 하나의 객체를 다양한 형태로 참조가 가능하다, 하나의 객체라고 하더라도 관점에 따라 다를 수 있다. 집에서는 아들, 학원에서는 학생

- Inheritage (상속): 기존 클래스를 재활용하는 것을 의미한다. 새로운 클래스를 만드는 것을 의미, 기존에 있는 설계도를 사용하거나 확장해서 새로운 객체를 만든다

- Encapsulation (캡슐화): 데이터와 로직이 한 단위로 묶여있는 것, 이 겍체가 가지고 있는 속성과 행위는 공개할 수 있는 것과 공개할 수 없는 것으로 이루어져 있다.

### 객체지향 프로그래밍 장점
- 모듈화된 프로그래밍이 가능하다.
    - 프로그램 중 낡은 기능을 가진 객체를 버리고 새로운 객체를 도입하면 된다.

- 재사용성이 높다.
    - 많은 설계도들이 만들어져 있으므로, 기존의 설계도를 고쳐서 새로운 설계도를 만들어낼 수 있다.

- 디버깅이 용이하다.
    - 어떠한 문제가 발생했을 때, 문제를 발견해내기가 쉽다. 해당 부분을 교체하면 되기 때문

- 정보를 보호하는 측면에서도 유리하다.

- 모듈화된 프로그래밍으로 협업에 유리하다.

### 클래스
- 관련있는 변수와 함수(메서드)를 묶어서 만든 사용자정의<자료형>
- 모든 객체들의 생산처
- 클래스 == 객체를 생성하는 틀
- 프로그래밍이 쓰이는 목적을 생각하여 어떤 객체를 만들어야 하는지 결정한다.
- 각 객체들이 어떤 특징(속성과 동작)을 가지고 있을지 결정한다.
- 클래스를 통해 생성된 객체를 인스턴스라고 한다.
- 객체들 사이에서 메세지를 주고 받도록 만들어 준다.

### **`클래스 구성`**
- 속성(Attribute) - 필드, 멤버변수
- 동작(Behabior) - 메소드, 멤버 메서드
- 생성자(Constructor)
- 중첩 클래스(클래스 내부의 클래스)

``` java

[접근제한자][활용제한자]class 클래스명 { // public = 다른 패키지에서 적용가능, default = 같은 패키지에서 적용가능
    속성 정의 (필드)
    기능 정의 (메소드)
    생성자
}

public class Person { // 속성 정의 (필드)
    String name;
    int age;
}

public void eat() { // 기능 정의 (메소드)
}

public Person { // 생성자
}
```

### 클래스 변수(class variable)
- 클래스 영역 선언 (static 키워드)
- 생성시기: 클래스가 메모리에 올라갔을 때
- 모든 인스턴스가 공유함

### 인스턴스 변수(Instance variable) //Instance -> 실제로 만들어진 객체
- 힙 영역 선언
- 생성시기: 인스턴스가 생성되었을 때(new)
- 인스턴스 별로 생성됨

### 지역 변수(local variable)
- 클래스 영역 이외(메서드, 생성자 ..등)
- 생성시기: 선언되었을 때

### 메소드 (Method)
- 객체가 할 수 있는 행동을 정의
- 어떤 작업을 수행하는 명령문의 집합에 이름을 붙여놓은 것
- 메소드의 이름은 소문자로 시작하는 것이 관례

[접근제한자][활용제한자] 반환값 메소드이름[매개변수들] {
    행위 기술...
}

public static void main(String [] args) {

}

### 메소드 선언
- 선언시 {} 안에 메소드가 해야할 일을 정의

### 메소드 호출
- 객체를 생성한 후 객체의 멤버 메서드를 호출한다.
- 클래스 객체.메소드 이름으로 호출

Person p = new Person();
p.info();

- static이 메소드에 선언되어 있을 때는 클래스이름.메소드 이름으로 호출

Person.hello();

### 매개변수(Parameter)
- 메소드에서 사용하는 것

### 인자(Argument)
- 호출하는 쪽에서 전달하는 것

- 매개변수 생략 가능
- 파라미터 전달 시 묵시적 형 변환

- 리턴 타입은 메소드를 선언할 때 지정, 없다면 void(return 문 생략 가능)
- 리턴 타입을 작성했다면 반드시 해당 타입의 값을 리턴
- 리턴 타입은 하나만 적용 가능

### **`메소드 오버로딩(Overloading)`**
- 이름이 같고 `매개변수가 다른` 메소드를 여러 개 정의하는 것
- 중복 코드에 대한 효율적 관리 가능
- 파라미터의 개수 또는 순서, 타입이 달라야 할 것 (파라미터 이름만 다른 것은 X)
- 리턴 타입이 다른 것은 의미 X

### 클래스
- 관련 있는 변수와 함수를 묶어 만든 사용자 정의 자료형

### 객체
- 하나의 역할을 수행하는 '메소드와 변수(데이터)'의 묶음

### 객체지향 프로그래밍
- 프로그램을 단순히 데이터와 처리 방법으로 나누는 것이 아니라, 프로그램을 수많은 '객체(object)'라는 기본 단위로 나누고 이를 상호작용으로 서술하는 방식

### 생성자
= new 키워드와 함께 호출하여 작성
- 클래스명과 동일
- 결과형 리턴값을 갖지 않음
- 객체가 생성될 때 반드시 하나의 생성자 호출
- 멤버필드의 초기화에 주로 사용
- 하나의 클래스 내부에 생성자가 하나도 없으면 자동적으로 default 생성자가 있는 것으로 인지
    - default 생성자: 매개 변수도 없고 내용도 없는 생성자
- 매개변수의 개수가 다르거나, 자료형의 다른 여러 개의 생성자가 있을 수 있음(생성자 오버로딩)
- 생성자의 첫번째 라인으로 this() 생성자를 사용하여 또 다른 생성자를 하나 호출 가능

### 생성자 특징
- 클래스 명과 이름이 동일(대,소문자)
- 반환타입이 없다. (void 작성x)

``` java
public class Dog {
    public Dog() {
        System.out.println("기본 생성자!");
        System.out.println("클래스 이름과 동일하고 반환타입 X");
    }
}
```

### 기본(디폴트) 생성자
- 클래스 내에 생성자가 한도 정의되어 있지 않을 경우 JVM이 자동으로 제공하는 생성자
- 형태: 매개변수가 없는 형태, 클래스 명() {}

### 파라미터가 있는 생성자
- 생성자의 목적이 필드 초기화
- 생성자 호출 시 값을 넘겨주어야 함
- 해당 생성자를 작성하면 JVM에서 기본 생성자를 추가하지 않음

### 생성자 오버로딩을 지원한다
- 클래스 내에 메소드 이름이 같고 매개변수의 타입 또는 개수가 다른 것

### this
- 참조 변수로써 객체 자신을 가리킴
- this를 이용하여 자신의 멤버 접근 가능
- 지역변수(매개변수)와 필드의 이름이 동일할 경우 필드임을 식별할 수 있게 함.
- 객체에 대한 참조이므로 static 영역에서 this 사용 불가

### this의 활용
- this 멤버변수
- this ([인자값..]): 생성자 호출
- this 생성자 호출 시 제한사항
    - 생성자 내에서만 호출이 가능함
    - 생성자 내에서 첫번째 구문에 위치해야 함